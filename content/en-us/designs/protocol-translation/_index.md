---
title: "Protocol Translation"
weight: 50
---

{{< synopsis-protocol-translation >}}
<!--more-->

## Challenge
At the edge of an IoT solution, devices are often interconnected and have to exchange data locally, i.e., without moving data over the internet.
As some of these devices may use different protocols that are not compatible with each other, protocols have to be translated.
For instance in industrial IoT solutions, the interfaces of machines often use different protocols and extracting the information from these machines for monitoring requires their translations into a common format that is usable by the backend infrastructure or by a local actor.
Other examples are smart home deployments, where different devices use different standards, but still need to exchange data, e.g., to control PV power generation depending on the internal power consumption of the home.

Typically, moving all data in an untranslated form over the internet into a backend that finally does the translation is not feasible for several reasons:

* The volume or velocity of the data generated by the local devices is too high for constant streaming of data generated by the devices in their respective formats.
* The devices use a communication stack that is not based on the [IP-Protocol]({{< ref "https://en.wikipedia.org/wiki/Internet_Protocol" >}}), e.g., serial connections.
* The devices use a technology for communication that is not usable for communication over the internet, e.g., [Bluetooth]({{< https://en.wikipedia.org/wiki/Bluetooth >}}).
* Connecting the devices directly to the internet or communication using such a prototcol would create a security risk, e.g., because the protocol does not support encryption or authentication mechanisms.

The protocol translation design described below will solve these challenge.



## Solution
IoT solutions address these challenges by applying the [Gateway]({{< ref "/designs/gateway" >}}) in combination with edge logic running on the gateway.
The edge logic on the gateway executes the translation of the industrial protocols into a common data format/protocol that can be processed by backend IT systems such as databases, data lakes or webservices.
An example of an architecture for such a solution may be as follows:

![IIoT Extraction Design](ProtocolTranslation.png)

The left-hand portion of this architecture represents the devices at the edge of the IoT solution that are connected by at least one [Gateway]({{< ref "/designs/gateway" >}}).
This gateway is the only component connected to the internet in this architecture and the red arrow indicates that this connection should be encrypted/protected accordingly.
The gateway runs the translation logic that translates the different protocols into a commonly usable format.
If data generated by one of the connected devices has to be pushed to the IoT backend, the gateway will securely transmit the data in a common format after the translation occurred.
This architecture also allows a device B to act upon data generated by device A or vice versa, because the gateway would be also able to translate the data emitted by device A into a format usable by device B.
 
The gateway also has a security purpose:
The connections inside the local network can be insecure (black), e.g., because some of the used protocols have no security features, while the internet-facing connections (red) have to be secured by state-of-the-art encryption & authentication mechanisms.
While encrypting all connections would be desirable in general, this would prevent using some well-established protocols for certain application that do not support such security mechanisms and thus require replacing the corresponding devices with newer ones (if available).
For certain devices and applications, such a replacement approach is economically not feasible which is why this approach is an acceptable tradeoff.
It is generally recommended that the connection from the gateway to the IoT backend uses [TLS 1.2]({{< ref "https://en.wikipedia.org/wiki/Transport_Layer_Security" >}}) with [mutual authentication]({{< ref "https://en.wikipedia.org/wiki/Mutual_authentication" >}}).
While this requires the gateway to have its own certificate, it ensures the authenticity and integrity of the data during transit between OT and IT.

In the following, we provide some examples for the aforementioned translation component that runs on the gateway in the context of Industrial IoT data extraction.
Note that these examples are not production ready code, but rather serve an education purpose.







## Example - Industrial IoT Data Extraction
Industrial machines are often equipped with or consist of sensors and other hardware such as programmable logic controllers ([PLC]({{< ref "/glossary/vocabulary#plc" >}})) that are used to monitor or control machine behavior.
As a prerequisite for a large set of [Industry 4.0]({{< ref "/glossary/vocabulary#industry40" >}}) use cases, it is required to access the data of the industrial machines and their components.
The two main main reasons why simply connecting these machines to a network or the internet is not viable are in line with those mentioned above:
* **Protocols:** There are many different communication standards for the aforementioned components of industrial machines, e.g., [OPC-UA]({{< ref "https://en.wikipedia.org/wiki/OPC_Unified_Architecture" >}}), [Modbus]({{< ref "https://en.wikipedia.org/wiki/Modbus" >}}), [CANBus]({{< ref "https://en.wikipedia.org/wiki/CAN_bus" >}}), [Profibus]({{< ref "https://en.wikipedia.org/wiki/Profibus" >}}).
Some of these standards have not been designed for the use over the internet and some, e.g., serial Modbus, of them are not even based on the [IP-Protocol]({{< ref "https://en.wikipedia.org/wiki/Internet_Protocol" >}}).
* **Security:** Connecting an industrial asset directly to the internet is a security risk as some of the aforementioned standards have little or no security features.
For instance, Modbus in its basic version does not have any kind of security mechanism that authenticates a system that reads or writes to the underlying industrial equipment.

As described above, the application of the protocol translation design requires the deployment of a [Gateway]({{< ref "/designs/gateway" >}}) to connect the machines as well as the provide a secure connection to the backend.
The local network on the left-hand side of the following architecture is commonly called *Shopfloor* in manufacturing or *operational technology (OT)*.
 

![IIoT Extraction Design](IIoT-Extraction-Architecture.png)


The gateway itself contains translation logic that translates between the machine protocol and the common protocol used by the IT systems.
In the example above, there are two machines - A and B.
Suppose Machine A has an interface that follows the [OPC-UA standard]({{< ref "https://en.wikipedia.org/wiki/OPC_Unified_Architecture" >}}) and Machine B uses [Modbus]({{< ref "https://en.wikipedia.org/wiki/Modbus" >}}).
In the following, we provide code samples that demonstrate the translation logic that has to run on the gateway.

#### Example: Translation OPC-UA
OPC-UA is a modern, IP-based protocol that has security features like in-transit encryption and authentication using certificates or username/password combinations.
The code below provides exemplary stub-code for accessing an OPC-UA target in Python: 

```python2
[... load some libraries, loggers ...]
# ######## STEP 1: load the library ######## 
from opcua import Client as OPCUAClient
POLLING_FREQUENCY = 5 # seconds

# definition of the data format to be retrieved
OPCUA_VARIABLES = {
	KEY_STATE				:	["Objects", "2:PLC1", "2:MAIN", "DrillState"],
	KEY_PRESSURE			:	["Objects", "2:PLC1", "2:MAIN", "Pressure"],
}

# generate a OPCUA url and create a client with it 
url = opc.tcp://192.168.2.2:4840 # assumes OPC-UA server at 192.168.2.2 on port 4840 on local network
client = OPCUAClient(url) # connect to the machine specified by the URL

# This function will run endlessly and poll the OPC-UA server
def poll_opcua_server():
	while True:
		try:
			# ######## STEP 2: Connect to the data source ######## 
			client.connect()
			rootNode = client.get_root_node()	# get the root node of the OPCUA tree
			# ######## STEP 3: Load the data from the source ######## 
			results = {}
			for name, path in OPCUA_VARIABLES.items():	# payload defines names -> path relations
				results[name] = rootNode.get_child(path).get_data_value()	# get the value from the node identified by path
			# ######## STEP 4: Publish the machine data ######## 
			# publish the result to the IoT endpoint as needed
			logger.info("Publishing the following extraction result: " + str(results))			
		except Exception as e:
			logger.error("Error while accessing OPCUA server: {0}".format(str(e)))
			logger.error("Error type: " + str(type(e)))
		finally:
			client.disconnect()
		time.sleep(POLLING_FREQUENCY)
# execute polling of opcua server
poll_opcua_server()
```

This example uses an open-source library specifically for OPC-UA that is available for Python.
The first line loads this library, more specifically the client class of the library.
The remainder of the script is straightforward:
The client class is used to establish a connection, read the result from the data source, i.e., the machine, and then publish the result to the IoT endpoint.
Note that the code required to publish to the IoT endpoint depends on the backend that is used and is therefore omitted here.
Additionally, this code does not use any authentication mechanism to keep the example simple. 
In general, it is recommended to authenticate the translation component. 


#### Example: Translation Modbus
As with the OPC-UA example above, this example assumes that data is accessible through a machine interface, but in this case the interface implements .
Similarly to the previous example, this example tries to access a machine with the IP address `192.168.2.2` on the local network, i.e., this example uses the TCP/IP variant of the [Modbus]({{< ref "https://en.wikipedia.org/wiki/Modbus" >}}) protocol.
The code for a serial interface of Modbus would require a different client, but the remainder of the code would remain unchanged:

```python2
[... load some libraries, loggers ...]
# ######## STEP 1: load the library ######## 
from pymodbus.client.sync import ModbusTcpClient as ModbusClient
POLLING_FREQUENCY = 1 	# second(s)
# Instantiate the client for your modbus slave device. 
mbClient = ModbusClient("192.168.2.2", port=5020)

def poll_measurements(frequency=POLLING_FREQUENCY):
	while True:
		# ######## STEP 2: Connect to the data source ########
		try:
			# connect to modbus slave device
			if not(mbClient.is_socket_open()):
				mbClient.connect()
		except Exception as e:
			time.sleep(1)
			continue
		# ######## STEP 3: Load the data from the source ########
		try:
			# read the holding registers (32 is chosen as a sufficient number of registers to hold the payload)
			readResult = mbClient.read_holding_registers(address=0x0, count=32, unit=1)
		except Exception as e:
			mbClient.close()
			time.sleep(1)
			continue
		# ######## STEP 4: Publish the machine data ######## 
		# publish the result to the IoT endpoint as needed
		logger.info("Publishing the following extraction result: " + str(results))			
		time.sleep(frequency)
poll_measurements()
```
The structure of this Python script is the same as before:
The first step of the script loads an open-source library that will provide easy access to Modbus assets.
Afterwards, the script will connect to the Modbus master and then get the data from the master.

It is important to note that the result from a Modbus master will be more "unstructured" compared to the OPC-UA example above:
The variable `readResult` will contain unstructured binary data that has to be reformatted depending on how the data was written to the bus.
This is a fundamental difference between a modern protocol like OPC-UA and Modbus when it comes to data extraction.

#### Summary
As shown in the above sections, the translation logic on the gateway has a common structure of four steps:

1. Loading of a protocol specific library
1. Establishing the connection to the asset from which data needs to be extracted.
1. Retrieving the desired data from the machine.
1. Optionally processing the data from the machine and then forwarding the data to the IT systems (over the internet).

Depending on the protocol, establishing the connection may require credentials or other authentication secrets that need to be stored securely on the gateway.
In the examples above, open-source libraries for Modbus and OPC-UA have been used, but commercial alternatives exist and can be used as well.

## Considerations

When implementing this design, consider the following questions:

#### Is the gateway component with the internet connection a security risk?
If the design is implemented in such a way that the gateway only accepts TLS 1.2 connections from the IoT endpoint and vice versa, this approach does not introduce additional security risks.
Using this approach, the data is encrypted during transit and the "internet-facing" endpoint of the gateway provides only a minimal attack surface that remains secure as long as the certificates are handled securely.

#### Does the schema for the translation logic change if the connection is not IP-based?
In general, the schema does not change.
In the examples above, the IP connection was always defined using an IP address.
For instance, to use a serial connection with Modbus, the corresponding hardware path has to be used instead of the IP address and a client specifically for Modbus over serial connections needs to be loaded instead of the TCP client.

#### Is there a way to delay/batch/aggregate messages on the gateway?
Aggregation or batching of data has not been part of the examples above to keep them concise and short.
The logic shown above can be easily extended with mechanisms that batch results or compute aggregations over them.

#### What happens if the connection of the gateway to the IT systems breaks?
The gateway will not be able to push the data to the IT systems anymore.
To prevent data loss, it is recommended to implement a backup storage mechanism for cases where Step 4 (Publishing data) fails.

#### Why do insecure protocols used in IoT solutions exist in the first place?
The reason for this is mostly that security is an evolving field and many of the protocols have been designed decades ago.
For instance, the first version of Modbus has been published in 1979 at a time when encryption or cyber security were not a priority for the design of a protocol.
There is a similar history for protocols used in other applications. 
While it would be preferable that all devices support modern, secure protocols, this is often not feasible as replacing such devices is costly.
Furthermore, modern security mechanisms sometimes exceed the compute capacity of devices, particularly if they are battery-powered. 


#### What is the risk of devices using insecure protocols directly to the internet?
Exposing devices with an insecure protocol to the internet will likely result in data loss or even attacks that manipulate the data.
Additionally, attackers can also try to control devices and use them for purposes that can be dangerous for humans around them or render the devices inoperable.
Hence, it is not recommended to connect devices using insecure protocols directly to the Internet and instead use a gateway in between to serve as the "internet-facing" frontend of the local network. 

#### What kind of hardware is used for the gateway?
This highly depends on the application and the surroundings of the application.
For instance, in the aforementioned Industrial IoT example, the gateway is an industrial PCs or similarly ruggedized hardware.
Other applications may deploy the translation logic on mobile phones or other similar devices.

